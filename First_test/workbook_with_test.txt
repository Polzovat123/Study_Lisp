			Task 1.1
1) 10
2) 12
3) 8
4) 3
5) 8 - 2 = 6
6) a = 3
7) Определяем данные b = a + 1 = 4
8) a + b + ab = 7 + 12 = 19
9) false == #f
10) 4
11) 16
12) 6
13) 16
Проверка:
1) +
2) +
3) +
4) +
5) +
6) (not show)(a=3)
7) +
8) +
9) +
10) +
11) +
12) +
13) +
			Task 1.2

(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) 
   (* 3 
      (- 6 2) 
      (-2 7)))
Проверка:
+
			Task 1.3

(define a 1)
(define b 2)
(define c 3)

(define (squear x) (* x x))

(define (sum x y) (+ (squear x) (squear y)))

(define (compare a b) (if (> a b) a b)

(define (bigger a b c) ((compare a (compare b c))))

(define (second_bigger a b c) (cond (() )
			   	    ()
			   	    
				()))
Проверка:
+
			Task 1.4
Процедура складывает а и модуль числа б.
Порверка:
+
			Task 1.5

1) Если апликативное то будет подставляться сразу тогда: 0 и p 
следовательно функция вернет 0 и п будет посчитана.
2) Если нормальный порядок то тогда p вычислят когда будет нужно то есть в конце следовательно функция вернет 0 а п не будет посчитано.
